---
apiVersion: v1
kind: ConfigMap
metadata:
  name: rubyapp-cfgmap
data:
  Gemfile: ""
  Gemfile.lock: |
    GEM
      specs:

    PLATFORMS
      ruby

    DEPENDENCIES

    BUNDLED WITH
       1.17.2
  main.rb: |
    require 'socket'
    require 'logger'

    # Load New Relic agent if available (injected by operator)
    begin
      require 'newrelic_rpm'
    rescue LoadError
      puts "New Relic agent not available (not injected yet)"
    end

    logger = Logger.new(STDOUT)
    logger.level = Logger::DEBUG

    class HttpServer
      include NewRelic::Agent::Instrumentation::ControllerInstrumentation if defined?(NewRelic)

      def initialize(logger, port)
        @server = TCPServer.new('0.0.0.0', port)
        @logger = logger
      end

      def accept_connection
        while session = @server.accept
          handle_request(session)
        end
      end

      def handle_request(session)
        request = session.readpartial(1024)
        @logger.info("peer #{session.peeraddr[3]}:#{session.peeraddr[1]} connected")
        STDERR.puts("peer #{session.peeraddr[3]}:#{session.peeraddr[1]} connected")

        verb, path, proto = request.lines[0].split
        scheme, ver = proto.split('/')
        @logger.info("requested #{verb} #{path} #{scheme} #{ver}")
        STDERR.puts("requested #{verb} #{path} #{scheme} #{ver}")

        # Set transaction name for New Relic
        if defined?(NewRelic)
          NewRelic::Agent.set_transaction_name("HttpServer/#{verb}#{path}")
        end

        session.write("HTTP/1.0 200 OK\r\n")
        session.write("Host: rubyapp\r\n")
        session.write("Connection: close\r\n")
        session.write("\r\n")
        session.write("hello world from ruby\n")
        session.write("peer: #{session.peeraddr[3]}:#{session.peeraddr[1]}\n")
        session.write("server: #{session.addr[3]}:#{session.addr[1]}\n")
        session.close
      rescue => e
        @logger.error("Error handling request: #{e.message}")
        STDERR.puts("Error handling request: #{e.message}")
        session.close rescue nil
      end

      # Instrument the handle_request method as a web transaction
      if defined?(NewRelic)
        add_transaction_tracer :handle_request,
                               category: :controller,
                               name: 'handle_request'
      end
    end

    logger.info("starting server")
    STDERR.puts("starting server")
    server = HttpServer.new(logger, 8080)
    server.accept_connection
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rubyapp
spec:
  selector:
    matchLabels:
      app: rubyapp
  replicas: 1
  template:
    metadata:
      labels:
        app: rubyapp
        app.newrelic.instrumentation: newrelic-ruby-agent
    spec:
      containers:
        - name: rubyapp
          image: ruby:3.3-alpine
          workingDir: /app
          env:
            - name: RUBYOPT
              value: -W2
          command:
            - sh
            - -c
            - |
              gem install bundler
              bundle install
              ruby main.rb
          ports:
            - containerPort: 8080
          volumeMounts:
            - mountPath: /app/
              name: code
      volumes:
        - name: code
          configMap:
            name: rubyapp-cfgmap
---
apiVersion: v1
kind: Service
metadata:
  name: rubyapp-service
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: rubyapp
